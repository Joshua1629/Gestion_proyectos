{
	"version": "2.0.0",
	"tasks": [
		{
			"label": "Restart backend (Windows)",
			"type": "shell",
			"command": "powershell -NoProfile -Command \"Get-Process -Name node -ErrorAction SilentlyContinue | Where-Object { $_.Path -like '*server*' } | Stop-Process -Force; Start-Process -NoNewWindow -FilePath node -ArgumentList 'server\\\\app.js'\"",
			"isBackground": false,
			"problemMatcher": [],
			"group": "build"
		},
		{
			"label": "Patch auth email validation",
			"type": "shell",
			"command": "powershell -NoProfile -Command \"$p='server/routes/auth.js'; (Get-Content $p) -replace \"body\\('email'\\)\\.optional\\(\\)\\.isEmail\\(\\)\", \"body('email').optional({ checkFalsy: true }).isEmail()\" | Set-Content $p\"",
			"isBackground": false,
			"problemMatcher": [],
			"group": "build"
		},
		{
			"label": "Restart backend after auth patch",
			"type": "shell",
			"command": "powershell -NoProfile -Command \"Get-Process -Name node -ErrorAction SilentlyContinue | Where-Object { $_.Path -like '*server*' } | Stop-Process -Force; Start-Process -NoNewWindow -FilePath node -ArgumentList 'server\\\\app.js'\"",
			"isBackground": false,
			"problemMatcher": [],
			"group": "build"
		},
		{
			"label": "Restart dev stack",
			"type": "shell",
			"command": "powershell -NoProfile -Command \"Get-Process -Name electron -ErrorAction SilentlyContinue | Stop-Process -Force; Get-Process -Name node -ErrorAction SilentlyContinue | Where-Object { $_.Path -like '*server*' } | Stop-Process -Force; Start-Process -NoNewWindow -FilePath npm -ArgumentList 'run dev'\"",
			"isBackground": false,
			"problemMatcher": [],
			"group": "build"
		},
		{
			"label": "Patch appFetch headers conversion",
			"type": "shell",
			"command": "powershell -NoProfile -Command \"$p='frontend/src/utils/appFetch.ts'; $c = Get-Content $p -Raw; $code = @'\nfunction headersToPlain(h: any): Record<string,string> {\n  try {\n    if (!h) return {};\n    if (typeof Headers !== 'undefined' && h instanceof Headers) {\n      const out: Record<string,string> = {};\n      (h as any).forEach((v: string, k: string) => { out[k] = v; });\n      return out;\n    }\n    if (typeof h === 'object') return { ...h } as any;\n  } catch {}\n  return {};\n}\n'@; if ($c -notmatch 'function headersToPlain') { $c = $code + \"`n\" + $c; $c | Set-Content $p } ; $c2 = (Get-Content $p -Raw) -replace 'api\\.fetch\\(url, \\{[\\s\\S]*?headers: opts\\.headers,','api.fetch(url, {`n      method: opts.method || '\\''GET'\\'',`n      headers: headersToPlain(opts.headers),'; Set-Content $p $c2; Write-Host 'Patched'\"",
			"isBackground": false,
			"problemMatcher": [],
			"group": "build"
		},
		{
			"label": "Edit appFetch.ts to add headersToPlain and use it",
			"type": "shell",
			"command": "powershell -NoProfile -Command \"$p='frontend/src/utils/appFetch.ts'; $src = Get-Content $p -Raw; $src = $src -replace 'export type AppFetchOptions([\\s\\S]*?)export async function','function headersToPlain(h:any):Record<string,string>{ try{ if(!h)return {}; if (typeof Headers!==\\'undefined\\' && h instanceof Headers){ const out:Record<string,string>={}; (h as any).forEach((v:string,k:string)=>out[k]=v); return out;} if (typeof h==='\\'object\\''){ return { ...(h as any) }; } }catch{} return {}; }`n`nexport type AppFetchOptions$1export async function'; $src = $src -replace 'headers: opts\\.headers,','headers: headersToPlain(opts.headers),'; Set-Content $p $src; Write-Host 'Patched appFetch'\"",
			"isBackground": false,
			"problemMatcher": [],
			"group": "build"
		},
		{
			"label": "Fix appFetch.ts content",
			"type": "shell",
			"command": "powershell -NoProfile -Command \"Set-Content -Path 'frontend/src/utils/appFetch.ts' -Encoding UTF8 -Value @'\nexport type AppFetchOptions = RequestInit & { asJson?: boolean };\n\nfunction headersToPlain(h: any): Record<string, string> {\n  try {\n    if (!h) return {};\n    // If it's a Headers instance\n    if (typeof Headers !== 'undefined' && h instanceof Headers) {\n      const out: Record<string, string> = {};\n      (h as any).forEach((v: string, k: string) => { out[k] = v; });\n      return out;\n    }\n    // Plain object\n    if (typeof h === 'object') return { ...(h as Record<string, string>) };\n  } catch {}\n  return {};\n}\n\nexport async function appFetch(url: string, options: AppFetchOptions = {}) {\n  const opts: RequestInit = { ...options };\n  const asJson = options.asJson !== false; // por defecto intentamos JSON\n\n  // Adjuntar Authorization si existe token y no fue especificado\n  try {\n    const token = (typeof localStorage !== 'undefined') ? localStorage.getItem('token') : null;\n    const hdrs = new Headers((opts.headers as any) || {});\n    if (token && !hdrs.has('Authorization')) {\n      hdrs.set('Authorization', `Bearer ${token}`);\n    }\n    opts.headers = hdrs as any;\n  } catch {}\n\n  // Preferir el puente IPC si existe (Electron preload)\n  const api = (globalThis as any).api;\n  const isFormData = typeof FormData !== 'undefined' && (opts as any).body instanceof FormData;\n\n  // Cuando usamos IPC normal (no multipart), convertir headers a objeto plano (Headers no cruza IPC)\n  if (api && typeof api.fetch === 'function' && !isFormData) {\n    const res = await api.fetch(url, {\n      method: opts.method || 'GET',\n      headers: headersToPlain(opts.headers),\n      body: opts.body,\n      credentials: (opts as any).credentials,\n    });\n    if (!res.ok) {\n      throw { status: res.status, statusText: res.statusText, ...(typeof res.body === 'object' ? res.body : { error: res.body }) };\n    }\n    return asJson ? res.body : res;\n  }\n\n  // Si estamos en Electron y el body es FormData, usar IPC upload para evitar problemas de red del renderer\n  if (api && typeof api.uploadMultipart === 'function' && isFormData) {\n    const fd = (opts as any).body as FormData;\n    const fields: Record<string, string> = {};\n    const files: Array<{ fieldName: string; name: string; type: string; buffer: ArrayBuffer }> = [];\n    (fd as any).forEach((value: any, key: string) => {\n      if (typeof File !== 'undefined' && value instanceof File) {\n        files.push({ fieldName: key, name: value.name, type: value.type || 'application/octet-stream', buffer: new ArrayBuffer(0) });\n      } else {\n        fields[key] = String(value);\n      }\n    });\n    for (const f of files) {\n      const v: any = (fd as any).get(f.fieldName);\n      if (v && typeof v.arrayBuffer === 'function') {\n        f.buffer = await v.arrayBuffer();\n        f.type = v.type || f.type;\n      }\n    }\n    let headers: Record<string, string> | undefined = undefined;\n    try {\n      const h = new Headers(opts.headers as any);\n      const auth = h.get('Authorization');\n      if (auth) headers = { Authorization: auth };\n    } catch {}\n    const res = await api.uploadMultipart({ url, method: opts.method || 'POST', fields, files, headers });\n    if (!res.ok) {\n      const body = res.body;\n      throw { status: res.status, statusText: res.statusText, ...(typeof body === 'object' ? body : { error: body }), ...(res.error ? { error: res.error } : {}) };\n    }\n    return asJson ? res.body : res;\n  }\n\n  // Fallback a fetch del navegador\n  const r = await fetch(url, opts);\n  if (!r.ok) {\n    let data: any = null;\n    try { data = await r.json(); } catch { data = await r.text(); }\n    throw { status: r.status, statusText: r.statusText, ...(typeof data === 'object' ? data : { error: data }) };\n  }\n  return asJson ? r.json() : r;\n}\n'@",
			"isBackground": false,
			"problemMatcher": [],
			"group": "build"
		},
		{
			"label": "test-login-usuario",
			"type": "shell",
			"command": "powershell",
			"args": [
				"-NoProfile",
				"-ExecutionPolicy",
				"Bypass",
				"-Command",
				"$ErrorActionPreference='Stop'; $body = @{ identifier='usuario'; password='1234' } | ConvertTo-Json; $resp = Invoke-RestMethod -Method POST -Uri 'http://127.0.0.1:3001/api/auth/login' -ContentType 'application/json' -Body $body; $resp | ConvertTo-Json -Depth 8"
			],
			"isBackground": false,
			"problemMatcher": []
		},
		{
			"label": "test-login-usuario-2",
			"type": "shell",
			"command": "powershell",
			"args": [
				"-NoProfile",
				"-ExecutionPolicy",
				"Bypass",
				"-Command",
				"$ErrorActionPreference='Stop'; $json = '{\"identifier\":\"usuario\",\"password\":\"1234\"}'; $resp = Invoke-RestMethod -Method POST -Uri 'http://127.0.0.1:3001/api/auth/login' -ContentType 'application/json' -Body $json; $resp | ConvertTo-Json -Depth 8"
			],
			"isBackground": false,
			"problemMatcher": []
		}
	]
}